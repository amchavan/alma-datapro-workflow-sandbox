# Java Message Bus Demos

These Eclipe projects implement example usages of the 
[RabbitMQ](https://www.rabbitmq.com)-based message broker.

The *alma.obops.draws.messages.examples* package includes a number of demos to show how the message bus can be used.

All examples try to show something sensible on the console. Message subscribers typically time out after some seconds of inactivity.

## Prerequisites

* A Java 8 environment including Maven
* A running instance of [CouchDB](couchdb.apache.org)
* A running instance of [RabbitMQ](https://www.rabbitmq.com)

## Build

Make sure you have built the [message bus](../README.md) first.

Then: if needed, clone the Git repository (`git clone https://github.com/amchavan/alma-datapro-workflow-sandbox.git`), change to the *message-bus-demos* directory and run  
`mvn clean package`  
That will create several jarfiles in the *target* subdirectories, for instance *basic-sender/target/basic-sender-&lt;version&gt;.jar*

**NOTE** The following examples assume the current working directory is *message-bus-demos*.

## Configuration

All demos depend on configuration parameters in *$ACSDATA/config/archiveConfig.properties*.  

### RabbitMQ server

Property `archive.rabbitmq.connection` should be set to something like  `http://localhost:5984`.

The server itself should _not_ be secured, or you'll need to provide username and password as well. Use properties `archive.rabbitmq.username` and `archive.rabbitmq.password` for that.

See *RabbitMqConfigurationProperties.java* for more configuration options.

### Relational server

The [message archival service](#message-archival) requires a relational database connection, to be configured in _archiveConfig.properties_ as per ALMA conventions. These demos use a MySQL database, to be configured for instance like:
```
archive.relational.connection = jdbc:mysql://localhost:3306/draws
archive.relational.user = root
archive.relational.passwd = mysql$dba
```
The code uses a single table called _envelope_ in the _draws_ database:
```sql
create table if not exists envelope (
    id int(11) auto_increment,
    envelope_id varchar(64),
    consumed_timestamp varchar(64),
    expired_timestamp varchar(64),
    message varchar(2048),
    message_class varchar(256),
    origin_ip varchar(64),
    queue_name varchar(256),
    received_timestamp varchar(64),
    sent_timestamp varchar(64),
    rejected_timestamp varchar(64),
    state varchar(64),
    time_to_live int(11),
    primary key(id)
);
```

## Basic send and receive

Modules `basic-sender` and `basic-receiver` exchange a simple message. Launch them as follows, on two separate terminal windows:

```bash
java -jar basic-receiver/target/*.jar qname=example.queue sname=receiver
java -jar basic-sender/target/*.jar qname=example.queue
```

Parameter `qname` identifies the queue a message will be published to. Parameter `sname` identifies which service is subscribing — there may be multiple subscribers for the same message, see below.

If you list the RabbitMQ queues (with `rabbitmqctl list_queues`) after they both terminate you'll see that queue _receiver.example.queue_ was created and is empty, because a message was sent and received. 

Queue _message.persistence.queue_ was also created, see below for more info.

## Secure send and receive

Modules `secure-sender` and `secure-receiver` behave very much the same as the basic version, but make sure the exchange is secured by way of a JWT. In this case the JWT is generated by _KWTFactory.java_ using hardcoded keys, in production you should configure them to use an external OIDC-based authentication server -- see _OidcConfigurationProperties.java_ and _TokenFactoryConfiguration.java_ for more info.  
Launch them as follows, on two separate terminal windows:

```bash
java -jar secure-receiver/target/*.jar qname=example.queue sname=receiver
java -jar secure-sender/target/*.jar qname=example.queue
```

Parameters `qname` and `sname` have the same meaning as above. In the logs you should be able to see the token exchanged between publisher and subscriber, and you can paste it for instance into
[this window](https://jwt.io/#debugger)
to decode it. You should see that the user (field _sub_) has the _OBOPS/AOD_ role that's required by the receiver. (See `ACCEPTED_ROLES` in _SecureReceiver.java_).

## Publish and subscribe

Modules `sender` and `receiver` implement a simple published/subscriber pair. In the simplest configuration, you can launch a single pair, as follows (and in two separate terminal windows):

```bash
java -jar receiver/target/*.jar qname=example.queue sname=receiver
java -jar sender/target/*.jar qname=example.queue
```

That would be equivalent to the previous demo. However, you can publish multiple messages with optional args _repeats_ and _delay_ (delay in seconds between repeats), for instance:  
`java -jar sender/target/*.jar qname=example.queue repeats=10 delay=1`

You can also start a second subscriber (in a new terminal window) with the same parameters: each subscriber will receive half of the messages. (Use case: providing more resources for a compute-intensive job.)

Finally, you can start a second subscriber but with a different service name, for instance:  
`java -jar receiver/target/*.jar qname=example.queue sname=receiver2`

In this case both subscribers will receive all messages. (Use case: broadcasting a message.)

## Request/reply — Remote Procedure Call

Modules `rpc-client` and `rpc-server` show how an RPC service (request/reply) can be implemented: the client (_ExecutorClient_) asks for the current time in UT and the server (_Executor_) returns that. You can launch a server and a client as follows:

```bash
java -jar rpc-server/target/*.jar &
java -jar rpc-client/target/*.jar
```

Note that the _rpc-client_ accepts the optional `repeats` and `delay` command-line args.

## Message archival

As we ran our examples, the _message.persistence.queue_ kept an increasing number of messages. (Try `rabbitmqctl list_queues`.) That queue is populated with any messages exchanged via the message bus and their status changes: for each message published anywhere the message persistence queue includes a copy of that message plus any state changes related to it, typically _Sent_ → _Received_ and _Received_ → _Consumed_.

The purpose to collect all that is to allow an independent service to store all exchanged events in a database for troubleshooting and traffic analysis. Module `message-archiver` is one such service: it creates a new database row for each message and updates the message state value as they change.  
You'll need a running MySQL installation and you should configure it as shown [here](#relational-server).

Launch the archiver with `java -jar message-archiver/target/*.jar` and let it process all its backlog. You can then connect to the server and run queries on it, for instance:
```sql
SELECT queue_name,
       envelope_id,
       sent_timestamp,
       state
FROM draws.envelope
ORDER BY sent_timestamp DESC
```